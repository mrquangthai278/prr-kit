# D3.js — Stack-Specific Review Rules

> Applies to: GR · SR · PR · AR · BR
> Detection signals: `from 'd3'`, `import * as d3`, `d3.select`, `d3.scaleLinear`, `d3.axisBottom`, `.enter().append`

---

## Security
- **[CRITICAL]** `.html(userContent)` called on a D3 selection with unencoded user data → XSS; D3 sets `innerHTML` directly. Use `.text(userContent)` for text content, or sanitize HTML with DOMPurify before passing to `.html()`.
- **[HIGH]** `d3.json(userUrl)` or `d3.csv(userUrl)` called with a URL derived from user input without validation → SSRF or loading of malicious data. Validate and allowlist URLs before passing to D3 fetch helpers.
- **[HIGH]** Dynamic SVG `<foreignObject>` elements populated with user-controlled HTML → XSS vector that bypasses SVG's normal escaping. Sanitize all HTML content placed inside `<foreignObject>` elements.
- **[MEDIUM]** Axis tick labels or tooltip content bound directly to raw user data values → unencoded strings rendered as SVG `text` content. D3 `.text()` is safe, but `.html()` or `innerHTML` on tooltip containers is not; sanitize before inserting.
- **[LOW]** D3 charts embedding data from external sources in SVG `<title>` or `<desc>` elements without encoding → minor content injection risk. Encode all external data used in SVG metadata.

---

## Performance
- **[HIGH]** Not using `selection.join()` (D3 v5+) for enter/update/exit pattern → manual three-phase code is verbose, error-prone, and slower to execute. Replace `.selectAll().data().enter().append()` chains with `.join()`.
- **[HIGH]** Rebuilding the entire chart (re-running enter/append on all elements) on every data update instead of updating existing elements → O(n) DOM operations on each change. Use the update selection to modify existing elements; only enter new ones and exit removed ones.
- **[HIGH]** No transition throttling or debouncing on resize-driven re-renders → chart redraws on every pixel of window resize. Debounce resize handlers with at least 100ms delay.
- **[MEDIUM]** Rendering thousands of SVG `<circle>` or `<path>` elements for large datasets → SVG DOM overhead causes frame drops. Switch to `<canvas>` rendering (D3 + Canvas API) or use `d3-tile` with WebGL for datasets above ~5,000 points.
- **[MEDIUM]** D3 scale functions (`d3.scaleLinear`, `d3.scaleBand`) recreated on every render without memoization in React → recalculation overhead and new references causing child re-renders. Memoize scales with `useMemo` keyed on data and dimensions.
- **[LOW]** `d3.csv` or `d3.json` called inside a render or effect without caching result → network request repeated on every render cycle. Load data once, store in state or ref, pass as prop.

---

## Architecture
- **[HIGH]** D3 DOM manipulation (`.append()`, `.attr()`, `.style()`) running alongside React rendering on the same elements → virtual DOM and actual DOM desync causing lost updates and React warnings. Let React own the DOM; use D3 only for math (scales, axes, path generators) and render SVG elements via JSX.
- **[MEDIUM]** Chart dimensions hardcoded as magic numbers instead of measured from the container → chart overflows or underutilizes space on different screen sizes. Use `ResizeObserver` on the container element and pass measured `width`/`height` to the chart.
- **[MEDIUM]** Data transformation (filtering, aggregation, normalization) mixed with rendering logic in the same function → hard to test and reuse. Separate data pipeline (pure functions) from rendering (D3/SVG operations).
- **[MEDIUM]** Axes, legends, and tooltips tightly coupled to chart internals → cannot reuse or test independently. Extract as separate components or factory functions receiving scales as arguments.
- **[LOW]** Using deprecated D3 v4 or v5 API patterns (`.on('zoom')` without `d3.zoom()`, old nest API) in a v7 codebase → subtle behavioral differences. Audit imports and replace deprecated patterns with v7 equivalents.

---

## Code Quality
- **[HIGH]** `d3.select<ElementType, Datum>()` called without TypeScript generics → selection typed as `Selection<BaseType, unknown, ...>`, losing all type safety on datum and element properties. Always provide element and datum type parameters.
- **[MEDIUM]** Chart margins defined as magic numbers inline → hardcoded values repeated across multiple chart files. Extract to a named config object `const margin = { top: 20, right: 30, bottom: 40, left: 50 }`.
- **[MEDIUM]** Transitions across charts using inconsistent durations and easing → jarring UX. Define shared transition presets and apply via `d3.transition('name')` named transitions.
- **[MEDIUM]** Tooltip element created via `d3.select('body').append('div')` without cleanup → orphaned tooltip `<div>` elements accumulate in the DOM. Remove tooltip in component cleanup/teardown.
- **[LOW]** Not using D3's built-in color schemes (`d3.schemeTableau10`, `d3.interpolateViridis`) → custom color arrays duplicated and inconsistent across charts. Use D3 ordinal and sequential color scales with built-in schemes.
- **[LOW]** SVG not given explicit `viewBox` and `preserveAspectRatio` attributes → SVG does not scale correctly in flexible containers. Always set `viewBox="0 0 ${width} ${height}"` on the root SVG element.

---

## Common Bugs & Pitfalls
- **[HIGH]** Data join key function omitted from `.data(dataset, d => d.id)` → D3 matches elements by index, causing wrong enter/exit assignment when data order changes. Always provide a key function that uniquely identifies each datum.
- **[HIGH]** `d3.scaleLinear().domain([d3.min(data), d3.max(data)])` when `data` contains non-numeric or `undefined` values → domain becomes `[NaN, NaN]`, all positions render at 0. Validate and filter data before computing domain; use `d3.extent` for safety.
- **[MEDIUM]** SVG y-axis inverted (y increases downward) not accounted for in scale range → chart renders upside down. Set scale range as `[height, 0]` for y-axis scales to flip the coordinate system.
- **[MEDIUM]** Tooltip not hidden on `mouseleave` from chart element → tooltip stays visible indefinitely after cursor exits. Always pair `mouseover`/`mouseenter` handlers with `mouseleave` handlers that hide the tooltip.
- **[MEDIUM]** `d3.zoom` transform applied to the wrong parent element → pan/zoom causes jumpy or offset behavior. Apply the transform to the inner `<g>` element, not the `<svg>`, and account for margin offset.
- **[MEDIUM]** `d3.brushX` selection not cleared when data updates → stale brush extent filters new data unexpectedly. Reset brush programmatically with `brush.move(brushGroup, null)` on data change.
- **[LOW]** `path.attr('d', lineGenerator)` called before data is bound to the selection → generator receives `undefined`, rendering an empty or broken path. Ensure data is joined before calling path generators.
