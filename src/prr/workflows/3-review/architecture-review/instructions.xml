<workflow>
  <critical>Workflow engine rules: {project-root}/_prr/core/tasks/workflow.xml</critical>
  <critical>Communicate all responses in {communication_language}</critical>
  <critical>Consistency with EXISTING codebase patterns is paramount â€” avoid over-engineering or introducing new patterns without strong justification</critical>
  <critical>Always consider: would a new team member understand where this code belongs and why?</critical>
  <critical>Finding severities: ğŸ”´ BLOCKER | ğŸŸ¡ WARNING | ğŸŸ¢ SUGGESTION | â“ QUESTION. Use â“ when you cannot determine intent or impact from the diff alone and need author confirmation before judging. A QUESTION that gets a bad answer becomes a BLOCKER or WARNING.</critical>

  <step n="1" goal="Load PR context, knowledge base, and understand the codebase structure">
    <check if="{pr_context} does not exist">
      <output>âŒ No PR selected. Please run [SP] Select PR first.</output>
      <stop/>
    </check>
    <action>Read {pr_context} and load git diff</action>
    <action>Load PR-specific knowledge base from {pr_knowledge_base}</action>
    <action>Extract architectural patterns from knowledge_base.relevant_guidelines (ARCHITECTURE.md sections, ADRs)</action>
    <action>Check pattern annotations from knowledge_base.inline_context (@pattern:)</action>
    <action>Also examine surrounding non-changed files to understand existing patterns</action>
    <output>ğŸ—ï¸ Starting Architecture Review
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Focus: Layer violations | Coupling | SOLID | Codebase consistency
Context: Loaded architectural patterns & ADRs from ARCHITECTURE.md
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</output>
  </step>

  <step n="2" goal="Check layer/separation of concerns violations">
    <check-list id="layers">
      <item>Business logic in controllers/routes (should be in services)</item>
      <item>Database queries in wrong layer (direct DB access from controller bypassing service)</item>
      <item>Presentation logic in backend (HTML generation in services)</item>
      <item>Infrastructure concerns mixed with domain logic</item>
      <item>Each function/class: does it have a single clear responsibility?</item>
    </check-list>
  </step>

  <step n="3" goal="Check coupling and cohesion">
    <check-list id="coupling">
      <item>Tight coupling: does this change force changes in many unrelated files?</item>
      <item>New module dependencies: are new imports appropriate? circular dependencies introduced?</item>
      <item>Interface design: are public APIs (function signatures, REST endpoints) clean and stable?</item>
      <item>Shared mutable state: global state introduced or modified across modules?</item>
    </check-list>
  </step>

  <step n="4" goal="Check consistency with existing codebase patterns">
    <check-list id="consistency">
      <item>Naming conventions: matches existing naming style (camelCase vs snake_case, etc.)?</item>
      <item>File/folder structure: new files placed where convention dictates?</item>
      <item>Error handling pattern: matches how errors are handled elsewhere in the codebase?</item>
      <item>API response format: matches existing response structure?</item>
      <item>New patterns: is a new pattern introduced? Is it justified and documented?</item>
    </check-list>
  </step>

  <step n="5" goal="Shared module blast radius and backward compatibility">
    <note>A change to any shared/common/generic module is high-risk because it affects all consumers â€” not just the code in this PR. This step must always run when any such file is changed.</note>
    <check-list id="blast-radius">
      <item>Identify: is the changed file a shared/common/generic resource? (utility modules, shared libraries, base classes, common interfaces/headers, core services, shared data models, global state)</item>
      <item>Consumer count: search for all files importing or using this module and list them. Any breaking change is a ğŸ”´ BLOCKER regardless of consumer count â€” high consumer count amplifies urgency but is not the deciding factor.</item>
      <item>Backward compatibility: is the public interface (function signatures, return shapes, exported types, event/message payloads, binary interfaces) backward compatible? If breaking: are ALL affected consumers updated in this same PR, or is there an explicit migration/deprecation plan?</item>
      <item>New required parameters without defaults are breaking changes â€” even if the author only updated their own call sites.</item>
      <item>Behavior change: does a behavioral change to a shared module produce unintended effects in contexts the author did not test (e.g., different runtime configurations, platforms, permission levels, or edge-case inputs)?</item>
      <item>Versioning / deprecation: if the change is intentionally breaking, is there a deprecation path? Is the old interface preserved with a deprecation notice?</item>
    </check-list>
    <output-format>
ğŸ”´ BLOCKER `src/common/HttpClient.ts` â€” `sendRequest()` param `timeout` removed. Breaking change.
   Consumer blast radius: ~23 files import this module (see Impact Map).
   Not all consumers updated in this PR: OrderService.ts, NotificationService.ts still pass `timeout`.
   â†’ Either restore `timeout` as optional/deprecated, or update all consumers in this PR.

â“ QUESTION `src/auth/AuthService.ts` â€” Return shape changed (added `permissions`, removed `roles`).
   Consumers outside diff: RouteGuard.ts, AdminMiddleware.ts, PermissionHelper.ts
   â†’ Ask author: "Were all consumers of AuthService tested with the new return shape? Was `roles` removal intentional?"
    </output-format>
  </step>

  <step n="6" goal="SOLID principles (only flag real violations, not theoretical ones)">
    <check-list id="solid">
      <item>SRP: class/module doing more than one thing AND causing maintenance problems?</item>
      <item>OCP: existing code modified instead of extended (when extension was clearly better)?</item>
      <item>LSP: subclass behavior violates parent contract?</item>
      <item>ISP: interface forces implementors to depend on methods they don't use?</item>
      <item>DIP: high-level module depends directly on low-level implementation (not abstraction)?</item>
    </check-list>
    <note>Only flag SOLID violations when they cause REAL maintainability or extensibility problems â€” not theoretical purity</note>
  </step>

  <step n="7" goal="Compile and write findings">
    <action>Group findings: Layer Violations | Coupling Issues | Consistency Problems | SOLID Violations | â“ Questions for Author</action>
    <action>For each finding: reference the EXISTING pattern that should be followed instead</action>
    <action>Write findings to {output_file}</action>
    <action>Update {pr_context}: add 'architecture-review' to completed list</action>
    <output>ğŸ—ï¸ Architecture review complete.
{blocker_count} blockers (ğŸ”´), {warning_count} warnings (ğŸŸ¡), {suggestion_count} suggestions (ğŸŸ¢), {question_count} questions (â“) for author.
Run [RR] Generate Report to compile all findings.</output>
  </step>
</workflow>
