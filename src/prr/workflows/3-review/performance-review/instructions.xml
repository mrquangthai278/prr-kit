<workflow>
  <critical>Workflow engine rules: {project-root}/_prr/core/tasks/workflow.xml</critical>
  <critical>Communicate all responses in {communication_language}</critical>
  <critical>Focus on IMPACTFUL performance issues â€” skip micro-optimizations that add complexity without measurable benefit</critical>
  <critical>Quantify impact when possible: "this adds ~Xms per request" or "X MB memory per session"</critical>
  <critical>Finding severities: ğŸ”´ BLOCKER | ğŸŸ¡ WARNING | ğŸŸ¢ SUGGESTION | â“ QUESTION. Use â“ when impact depends on context you cannot determine from the diff â€” e.g., "Is this function called in a hot path?", "What is the expected data volume here?". A QUESTION that gets a bad answer becomes a BLOCKER or WARNING.</critical>

  <step n="1" goal="Load PR context, knowledge base, and diff">
    <check if="{pr_context} does not exist">
      <output>âŒ No PR selected. Please run [SP] Select PR first.</output>
      <stop/>
    </check>
    <action>Read {pr_context} and load git diff</action>
    <action>Load PR-specific knowledge base from {pr_knowledge_base}</action>
    <action>Extract performance guidelines from knowledge_base.relevant_guidelines</action>
    <action>Adapt review scope: use knowledge_base.stack_context, knowledge_base.files_analysis, and knowledge_base.reviewer_guidance.performance_review to evaluate which of the default check categories below are relevant to this project and this PR. Categories that have no applicability to the detected project type should be skipped entirely.</action>
    <action>Identify stack-specific performance rules from knowledge_base.stack_context.rules â€” these will be applied as additional checks in the dedicated step below.</action>
    <output>âš¡ Starting Performance Review
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Scope: Adapted to detected stack and project context
Context: Loaded performance best practices from docs
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</output>
  </step>

  <step n="2" goal="Database and query performance">
    <note>Run only if relevant to the project type and the changes in this PR. Skip entirely if this category has no applicability.</note>
    <check-list id="database">
      <item>N+1 queries: DB call inside a loop? Should use batch/join instead</item>
      <item>Missing pagination: queries that could return unbounded result sets</item>
      <item>SELECT *: fetching all columns when only a few are needed</item>
      <item>Missing index: filtering/sorting on non-indexed columns</item>
      <item>Unnecessary queries: data already available in context/cache but re-fetched</item>
      <item>Transaction missing: multiple DB writes without transaction (data integrity risk)</item>
    </check-list>
  </step>

  <step n="3" goal="Async and concurrency patterns">
    <note>Run only if relevant to the project type and the changes in this PR. Skip entirely if this category has no applicability.</note>
    <check-list id="async">
      <item>Sequential awaits in loop: `for (x of arr) { await fn(x) }` should be Promise.all</item>
      <item>Unnecessary await: async function that doesn't need to be async</item>
      <item>Missing error handling on async operations</item>
      <item>Blocking operations on main thread/event loop</item>
      <item>Race conditions: shared state mutated from multiple async paths</item>
    </check-list>
  </step>

  <step n="4" goal="Memory management">
    <note>Run only if relevant to the project type and the changes in this PR. Skip entirely if this category has no applicability.</note>
    <check-list id="memory">
      <item>Event listener cleanup: listeners added but not removed (memory leak pattern)</item>
      <item>Large objects held in closure/module scope unnecessarily</item>
      <item>Accumulating arrays/objects without cleanup</item>
      <item>setInterval/setTimeout without clearInterval/clearTimeout</item>
      <item>Frontend: components not cleaning up on unmount</item>
    </check-list>
  </step>

  <step n="5" goal="Frontend performance (if applicable)">
    <note>Run only if relevant to the project type and the changes in this PR. Skip entirely if this category has no applicability.</note>
    <check-list id="frontend">
      <item>Bundle size: large new dependencies imported? Is tree-shaking possible?</item>
      <item>Unnecessary re-renders: state changes causing full component re-renders</item>
      <item>Images/assets: unoptimized media, missing lazy loading</item>
      <item>Blocking scripts or render-blocking resources</item>
      <item>Expensive computations in render path (should be memoized)</item>
    </check-list>
  </step>

  <step n="5b" goal="Stack-specific and project-specific performance checks">
    <action>Apply all performance rules from knowledge_base.stack_context.rules for each detected stack</action>
    <action>Apply performance-related guidelines from knowledge_base.relevant_guidelines</action>
    <action>Apply guidance from knowledge_base.reviewer_guidance.performance_review</action>
    <note>Generate additional checks specific to this project's technology and domain that go beyond the default categories above. If knowledge_base contains no stack-specific performance rules, skip this step silently.</note>
  </step>

  <step n="6" goal="Compile and write findings">
    <action>Distinguish: impactful issues vs micro-optimizations â€” only include impactful ones</action>
    <action>For each finding: assign severity based on impact scope â€” ğŸ”´ if causes measurable regression or data integrity risk, ğŸŸ¡ if significant but not blocking, ğŸŸ¢ if low-impact optimization, â“ if impact cannot be determined without author context</action>
    <action>Include a one-line impact rationale per finding (e.g., "adds ~Xms per request", "O(nÂ²) on unbounded input", "leaks ~X MB per session")</action>
    <action>Group findings by severity: ğŸ”´ Blockers â†’ ğŸŸ¡ Warnings â†’ ğŸŸ¢ Suggestions â†’ â“ Questions for Author</action>
    <action>Write findings to {output_file}</action>
    <action>Update {pr_context}: add 'performance-review' to completed list</action>
    <output>âš¡ Performance review complete.
{blocker_count} blockers (ğŸ”´), {warning_count} warnings (ğŸŸ¡), {suggestion_count} suggestions (ğŸŸ¢), {question_count} questions (â“) for author.
Run [RR] Generate Report to compile all findings.</output>
  </step>
</workflow>
